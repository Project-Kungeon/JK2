// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Message_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Message_2eproto;
namespace message {
class C_Attack;
struct C_AttackDefaultTypeInternal;
extern C_AttackDefaultTypeInternal _C_Attack_default_instance_;
class C_EnterRoom;
struct C_EnterRoomDefaultTypeInternal;
extern C_EnterRoomDefaultTypeInternal _C_EnterRoom_default_instance_;
class C_LeaveRoom;
struct C_LeaveRoomDefaultTypeInternal;
extern C_LeaveRoomDefaultTypeInternal _C_LeaveRoom_default_instance_;
class C_Login;
struct C_LoginDefaultTypeInternal;
extern C_LoginDefaultTypeInternal _C_Login_default_instance_;
class C_Move;
struct C_MoveDefaultTypeInternal;
extern C_MoveDefaultTypeInternal _C_Move_default_instance_;
class C_PickUp;
struct C_PickUpDefaultTypeInternal;
extern C_PickUpDefaultTypeInternal _C_PickUp_default_instance_;
class S_Attack;
struct S_AttackDefaultTypeInternal;
extern S_AttackDefaultTypeInternal _S_Attack_default_instance_;
class S_Despawn;
struct S_DespawnDefaultTypeInternal;
extern S_DespawnDefaultTypeInternal _S_Despawn_default_instance_;
class S_EnterRoom;
struct S_EnterRoomDefaultTypeInternal;
extern S_EnterRoomDefaultTypeInternal _S_EnterRoom_default_instance_;
class S_LeaveRoom;
struct S_LeaveRoomDefaultTypeInternal;
extern S_LeaveRoomDefaultTypeInternal _S_LeaveRoom_default_instance_;
class S_Login;
struct S_LoginDefaultTypeInternal;
extern S_LoginDefaultTypeInternal _S_Login_default_instance_;
class S_Move;
struct S_MoveDefaultTypeInternal;
extern S_MoveDefaultTypeInternal _S_Move_default_instance_;
class S_PickUp;
struct S_PickUpDefaultTypeInternal;
extern S_PickUpDefaultTypeInternal _S_PickUp_default_instance_;
class S_Spawn;
struct S_SpawnDefaultTypeInternal;
extern S_SpawnDefaultTypeInternal _S_Spawn_default_instance_;
}  // namespace message
PROTOBUF_NAMESPACE_OPEN
template<> ::message::C_Attack* Arena::CreateMaybeMessage<::message::C_Attack>(Arena*);
template<> ::message::C_EnterRoom* Arena::CreateMaybeMessage<::message::C_EnterRoom>(Arena*);
template<> ::message::C_LeaveRoom* Arena::CreateMaybeMessage<::message::C_LeaveRoom>(Arena*);
template<> ::message::C_Login* Arena::CreateMaybeMessage<::message::C_Login>(Arena*);
template<> ::message::C_Move* Arena::CreateMaybeMessage<::message::C_Move>(Arena*);
template<> ::message::C_PickUp* Arena::CreateMaybeMessage<::message::C_PickUp>(Arena*);
template<> ::message::S_Attack* Arena::CreateMaybeMessage<::message::S_Attack>(Arena*);
template<> ::message::S_Despawn* Arena::CreateMaybeMessage<::message::S_Despawn>(Arena*);
template<> ::message::S_EnterRoom* Arena::CreateMaybeMessage<::message::S_EnterRoom>(Arena*);
template<> ::message::S_LeaveRoom* Arena::CreateMaybeMessage<::message::S_LeaveRoom>(Arena*);
template<> ::message::S_Login* Arena::CreateMaybeMessage<::message::S_Login>(Arena*);
template<> ::message::S_Move* Arena::CreateMaybeMessage<::message::S_Move>(Arena*);
template<> ::message::S_PickUp* Arena::CreateMaybeMessage<::message::S_PickUp>(Arena*);
template<> ::message::S_Spawn* Arena::CreateMaybeMessage<::message::S_Spawn>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace message {

enum HEADER : int {
  NONE = 0,
  LOGIN_REQ = 1,
  LOGIN_RES = 2,
  ENTER_ROOM_REQ = 3,
  ENTER_ROOM_RES = 4,
  LEAVE_ROOM_REQ = 5,
  LEAVE_ROOM_RES = 6,
  LEAVE_GAME_REQ = 7,
  LEAVE_GAME_RES = 8,
  PLAYER_SPAWN_RES = 9,
  PLAYER_DESPAWN_RES = 10,
  PLAYER_CHAT_REQ = 11,
  PLAYERT_RES = 12,
  PLAYER_MOVE_REQ = 13,
  PLAYER_MOVE_RES = 14,
  PLAYER_ATTACK_REQ = 15,
  PLAYER_ATTACK_RES = 16,
  HEADER_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HEADER_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HEADER_IsValid(int value);
constexpr HEADER HEADER_MIN = NONE;
constexpr HEADER HEADER_MAX = PLAYER_ATTACK_RES;
constexpr int HEADER_ARRAYSIZE = HEADER_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HEADER_descriptor();
template<typename T>
inline const std::string& HEADER_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HEADER>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HEADER_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HEADER_descriptor(), enum_t_value);
}
inline bool HEADER_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HEADER* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HEADER>(
    HEADER_descriptor(), name, value);
}
// ===================================================================

class C_Login final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:message.C_Login) */ {
 public:
  inline C_Login() : C_Login(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Login(const C_Login& from);
  C_Login(C_Login&& from) noexcept
    : C_Login() {
    *this = ::std::move(from);
  }

  inline C_Login& operator=(const C_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Login& operator=(C_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Login* internal_default_instance() {
    return reinterpret_cast<const C_Login*>(
               &_C_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_Login& a, C_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_Login& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_Login& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.C_Login";
  }
  protected:
  explicit C_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:message.C_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class S_Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.S_Login) */ {
 public:
  inline S_Login() : S_Login(nullptr) {}
  ~S_Login() override;
  explicit PROTOBUF_CONSTEXPR S_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Login(const S_Login& from);
  S_Login(S_Login&& from) noexcept
    : S_Login() {
    *this = ::std::move(from);
  }

  inline S_Login& operator=(const S_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Login& operator=(S_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Login* internal_default_instance() {
    return reinterpret_cast<const S_Login*>(
               &_S_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_Login& a, S_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Login& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Login* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.S_Login";
  }
  protected:
  explicit S_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .message.ObjectInfo players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::message::ObjectInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::ObjectInfo >*
      mutable_players();
  private:
  const ::message::ObjectInfo& _internal_players(int index) const;
  ::message::ObjectInfo* _internal_add_players();
  public:
  const ::message::ObjectInfo& players(int index) const;
  ::message::ObjectInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::ObjectInfo >&
      players() const;

  // uint32 success = 1;
  void clear_success();
  uint32_t success() const;
  void set_success(uint32_t value);
  private:
  uint32_t _internal_success() const;
  void _internal_set_success(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.S_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::ObjectInfo > players_;
  uint32_t success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class C_EnterRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.C_EnterRoom) */ {
 public:
  inline C_EnterRoom() : C_EnterRoom(nullptr) {}
  ~C_EnterRoom() override;
  explicit PROTOBUF_CONSTEXPR C_EnterRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EnterRoom(const C_EnterRoom& from);
  C_EnterRoom(C_EnterRoom&& from) noexcept
    : C_EnterRoom() {
    *this = ::std::move(from);
  }

  inline C_EnterRoom& operator=(const C_EnterRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EnterRoom& operator=(C_EnterRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EnterRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EnterRoom* internal_default_instance() {
    return reinterpret_cast<const C_EnterRoom*>(
               &_C_EnterRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(C_EnterRoom& a, C_EnterRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EnterRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EnterRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EnterRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EnterRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EnterRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_EnterRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EnterRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.C_EnterRoom";
  }
  protected:
  explicit C_EnterRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIndexFieldNumber = 1,
  };
  // uint64 playerIndex = 1;
  void clear_playerindex();
  uint64_t playerindex() const;
  void set_playerindex(uint64_t value);
  private:
  uint64_t _internal_playerindex() const;
  void _internal_set_playerindex(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.C_EnterRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t playerindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class S_EnterRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.S_EnterRoom) */ {
 public:
  inline S_EnterRoom() : S_EnterRoom(nullptr) {}
  ~S_EnterRoom() override;
  explicit PROTOBUF_CONSTEXPR S_EnterRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EnterRoom(const S_EnterRoom& from);
  S_EnterRoom(S_EnterRoom&& from) noexcept
    : S_EnterRoom() {
    *this = ::std::move(from);
  }

  inline S_EnterRoom& operator=(const S_EnterRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EnterRoom& operator=(S_EnterRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EnterRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EnterRoom* internal_default_instance() {
    return reinterpret_cast<const S_EnterRoom*>(
               &_S_EnterRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_EnterRoom& a, S_EnterRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EnterRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EnterRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EnterRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EnterRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EnterRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_EnterRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EnterRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.S_EnterRoom";
  }
  protected:
  explicit S_EnterRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .message.ObjectInfo player = 2;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::message::ObjectInfo& player() const;
  PROTOBUF_NODISCARD ::message::ObjectInfo* release_player();
  ::message::ObjectInfo* mutable_player();
  void set_allocated_player(::message::ObjectInfo* player);
  private:
  const ::message::ObjectInfo& _internal_player() const;
  ::message::ObjectInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::message::ObjectInfo* player);
  ::message::ObjectInfo* unsafe_arena_release_player();

  // uint32 success = 1;
  void clear_success();
  uint32_t success() const;
  void set_success(uint32_t value);
  private:
  uint32_t _internal_success() const;
  void _internal_set_success(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.S_EnterRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::message::ObjectInfo* player_;
  uint32_t success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class C_LeaveRoom final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:message.C_LeaveRoom) */ {
 public:
  inline C_LeaveRoom() : C_LeaveRoom(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_LeaveRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LeaveRoom(const C_LeaveRoom& from);
  C_LeaveRoom(C_LeaveRoom&& from) noexcept
    : C_LeaveRoom() {
    *this = ::std::move(from);
  }

  inline C_LeaveRoom& operator=(const C_LeaveRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LeaveRoom& operator=(C_LeaveRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LeaveRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LeaveRoom* internal_default_instance() {
    return reinterpret_cast<const C_LeaveRoom*>(
               &_C_LeaveRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_LeaveRoom& a, C_LeaveRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LeaveRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LeaveRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LeaveRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LeaveRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_LeaveRoom& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_LeaveRoom& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.C_LeaveRoom";
  }
  protected:
  explicit C_LeaveRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:message.C_LeaveRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class S_LeaveRoom final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:message.S_LeaveRoom) */ {
 public:
  inline S_LeaveRoom() : S_LeaveRoom(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_LeaveRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LeaveRoom(const S_LeaveRoom& from);
  S_LeaveRoom(S_LeaveRoom&& from) noexcept
    : S_LeaveRoom() {
    *this = ::std::move(from);
  }

  inline S_LeaveRoom& operator=(const S_LeaveRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LeaveRoom& operator=(S_LeaveRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LeaveRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LeaveRoom* internal_default_instance() {
    return reinterpret_cast<const S_LeaveRoom*>(
               &_S_LeaveRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(S_LeaveRoom& a, S_LeaveRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LeaveRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LeaveRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LeaveRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LeaveRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_LeaveRoom& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_LeaveRoom& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.S_LeaveRoom";
  }
  protected:
  explicit S_LeaveRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:message.S_LeaveRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class S_Spawn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.S_Spawn) */ {
 public:
  inline S_Spawn() : S_Spawn(nullptr) {}
  ~S_Spawn() override;
  explicit PROTOBUF_CONSTEXPR S_Spawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Spawn(const S_Spawn& from);
  S_Spawn(S_Spawn&& from) noexcept
    : S_Spawn() {
    *this = ::std::move(from);
  }

  inline S_Spawn& operator=(const S_Spawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Spawn& operator=(S_Spawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Spawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Spawn* internal_default_instance() {
    return reinterpret_cast<const S_Spawn*>(
               &_S_Spawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(S_Spawn& a, S_Spawn& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Spawn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Spawn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Spawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Spawn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Spawn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Spawn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Spawn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.S_Spawn";
  }
  protected:
  explicit S_Spawn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .message.ObjectInfo players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::message::ObjectInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::ObjectInfo >*
      mutable_players();
  private:
  const ::message::ObjectInfo& _internal_players(int index) const;
  ::message::ObjectInfo* _internal_add_players();
  public:
  const ::message::ObjectInfo& players(int index) const;
  ::message::ObjectInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::ObjectInfo >&
      players() const;

  // @@protoc_insertion_point(class_scope:message.S_Spawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::ObjectInfo > players_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class S_Despawn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.S_Despawn) */ {
 public:
  inline S_Despawn() : S_Despawn(nullptr) {}
  ~S_Despawn() override;
  explicit PROTOBUF_CONSTEXPR S_Despawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Despawn(const S_Despawn& from);
  S_Despawn(S_Despawn&& from) noexcept
    : S_Despawn() {
    *this = ::std::move(from);
  }

  inline S_Despawn& operator=(const S_Despawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Despawn& operator=(S_Despawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Despawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Despawn* internal_default_instance() {
    return reinterpret_cast<const S_Despawn*>(
               &_S_Despawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_Despawn& a, S_Despawn& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Despawn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Despawn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Despawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Despawn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Despawn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Despawn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Despawn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.S_Despawn";
  }
  protected:
  explicit S_Despawn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdsFieldNumber = 1,
  };
  // repeated uint64 object_ids = 1;
  int object_ids_size() const;
  private:
  int _internal_object_ids_size() const;
  public:
  void clear_object_ids();
  private:
  uint64_t _internal_object_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_object_ids() const;
  void _internal_add_object_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_object_ids();
  public:
  uint64_t object_ids(int index) const;
  void set_object_ids(int index, uint64_t value);
  void add_object_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      object_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_object_ids();

  // @@protoc_insertion_point(class_scope:message.S_Despawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > object_ids_;
  mutable std::atomic<int> _object_ids_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class C_Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.C_Move) */ {
 public:
  inline C_Move() : C_Move(nullptr) {}
  ~C_Move() override;
  explicit PROTOBUF_CONSTEXPR C_Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Move(const C_Move& from);
  C_Move(C_Move&& from) noexcept
    : C_Move() {
    *this = ::std::move(from);
  }

  inline C_Move& operator=(const C_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Move& operator=(C_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Move* internal_default_instance() {
    return reinterpret_cast<const C_Move*>(
               &_C_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(C_Move& a, C_Move& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Move* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Move>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Move& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_Move& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Move* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.C_Move";
  }
  protected:
  explicit C_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 1,
  };
  // .message.PosInfo PosInfo = 1;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::message::PosInfo& posinfo() const;
  PROTOBUF_NODISCARD ::message::PosInfo* release_posinfo();
  ::message::PosInfo* mutable_posinfo();
  void set_allocated_posinfo(::message::PosInfo* posinfo);
  private:
  const ::message::PosInfo& _internal_posinfo() const;
  ::message::PosInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::message::PosInfo* posinfo);
  ::message::PosInfo* unsafe_arena_release_posinfo();

  // @@protoc_insertion_point(class_scope:message.C_Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::message::PosInfo* posinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class S_Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.S_Move) */ {
 public:
  inline S_Move() : S_Move(nullptr) {}
  ~S_Move() override;
  explicit PROTOBUF_CONSTEXPR S_Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Move(const S_Move& from);
  S_Move(S_Move&& from) noexcept
    : S_Move() {
    *this = ::std::move(from);
  }

  inline S_Move& operator=(const S_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Move& operator=(S_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Move* internal_default_instance() {
    return reinterpret_cast<const S_Move*>(
               &_S_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S_Move& a, S_Move& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Move* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Move>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Move& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Move& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Move* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.S_Move";
  }
  protected:
  explicit S_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 1,
  };
  // .message.PosInfo PosInfo = 1;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::message::PosInfo& posinfo() const;
  PROTOBUF_NODISCARD ::message::PosInfo* release_posinfo();
  ::message::PosInfo* mutable_posinfo();
  void set_allocated_posinfo(::message::PosInfo* posinfo);
  private:
  const ::message::PosInfo& _internal_posinfo() const;
  ::message::PosInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::message::PosInfo* posinfo);
  ::message::PosInfo* unsafe_arena_release_posinfo();

  // @@protoc_insertion_point(class_scope:message.S_Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::message::PosInfo* posinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class C_Attack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.C_Attack) */ {
 public:
  inline C_Attack() : C_Attack(nullptr) {}
  ~C_Attack() override;
  explicit PROTOBUF_CONSTEXPR C_Attack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Attack(const C_Attack& from);
  C_Attack(C_Attack&& from) noexcept
    : C_Attack() {
    *this = ::std::move(from);
  }

  inline C_Attack& operator=(const C_Attack& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Attack& operator=(C_Attack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Attack& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Attack* internal_default_instance() {
    return reinterpret_cast<const C_Attack*>(
               &_C_Attack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(C_Attack& a, C_Attack& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Attack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Attack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Attack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Attack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Attack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_Attack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Attack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.C_Attack";
  }
  protected:
  explicit C_Attack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttackObjectIdFieldNumber = 1,
    kVictimObjectIdFieldNumber = 2,
    kDamageFieldNumber = 3,
  };
  // uint64 attack_object_id = 1;
  void clear_attack_object_id();
  uint64_t attack_object_id() const;
  void set_attack_object_id(uint64_t value);
  private:
  uint64_t _internal_attack_object_id() const;
  void _internal_set_attack_object_id(uint64_t value);
  public:

  // uint64 victim_object_id = 2;
  void clear_victim_object_id();
  uint64_t victim_object_id() const;
  void set_victim_object_id(uint64_t value);
  private:
  uint64_t _internal_victim_object_id() const;
  void _internal_set_victim_object_id(uint64_t value);
  public:

  // uint32 damage = 3;
  void clear_damage();
  uint32_t damage() const;
  void set_damage(uint32_t value);
  private:
  uint32_t _internal_damage() const;
  void _internal_set_damage(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.C_Attack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t attack_object_id_;
  uint64_t victim_object_id_;
  uint32_t damage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class S_Attack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.S_Attack) */ {
 public:
  inline S_Attack() : S_Attack(nullptr) {}
  ~S_Attack() override;
  explicit PROTOBUF_CONSTEXPR S_Attack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Attack(const S_Attack& from);
  S_Attack(S_Attack&& from) noexcept
    : S_Attack() {
    *this = ::std::move(from);
  }

  inline S_Attack& operator=(const S_Attack& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Attack& operator=(S_Attack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Attack& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Attack* internal_default_instance() {
    return reinterpret_cast<const S_Attack*>(
               &_S_Attack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_Attack& a, S_Attack& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Attack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Attack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Attack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Attack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Attack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Attack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Attack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.S_Attack";
  }
  protected:
  explicit S_Attack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVictimsObjectIdsFieldNumber = 2,
    kObjectIdFieldNumber = 1,
    kDamageFieldNumber = 3,
  };
  // repeated uint64 victims_object_ids = 2;
  int victims_object_ids_size() const;
  private:
  int _internal_victims_object_ids_size() const;
  public:
  void clear_victims_object_ids();
  private:
  uint64_t _internal_victims_object_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_victims_object_ids() const;
  void _internal_add_victims_object_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_victims_object_ids();
  public:
  uint64_t victims_object_ids(int index) const;
  void set_victims_object_ids(int index, uint64_t value);
  void add_victims_object_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      victims_object_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_victims_object_ids();

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint32 damage = 3;
  void clear_damage();
  uint32_t damage() const;
  void set_damage(uint32_t value);
  private:
  uint32_t _internal_damage() const;
  void _internal_set_damage(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.S_Attack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > victims_object_ids_;
  mutable std::atomic<int> _victims_object_ids_cached_byte_size_;
  uint64_t object_id_;
  uint32_t damage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class C_PickUp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.C_PickUp) */ {
 public:
  inline C_PickUp() : C_PickUp(nullptr) {}
  ~C_PickUp() override;
  explicit PROTOBUF_CONSTEXPR C_PickUp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PickUp(const C_PickUp& from);
  C_PickUp(C_PickUp&& from) noexcept
    : C_PickUp() {
    *this = ::std::move(from);
  }

  inline C_PickUp& operator=(const C_PickUp& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PickUp& operator=(C_PickUp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PickUp& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PickUp* internal_default_instance() {
    return reinterpret_cast<const C_PickUp*>(
               &_C_PickUp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(C_PickUp& a, C_PickUp& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PickUp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PickUp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PickUp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PickUp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PickUp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_PickUp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PickUp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.C_PickUp";
  }
  protected:
  explicit C_PickUp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemInfoFieldNumber = 3,
    kObjectIdFieldNumber = 1,
    kPickedObjectIdFieldNumber = 2,
  };
  // .message.ItemInfo item_info = 3;
  bool has_item_info() const;
  private:
  bool _internal_has_item_info() const;
  public:
  void clear_item_info();
  const ::message::ItemInfo& item_info() const;
  PROTOBUF_NODISCARD ::message::ItemInfo* release_item_info();
  ::message::ItemInfo* mutable_item_info();
  void set_allocated_item_info(::message::ItemInfo* item_info);
  private:
  const ::message::ItemInfo& _internal_item_info() const;
  ::message::ItemInfo* _internal_mutable_item_info();
  public:
  void unsafe_arena_set_allocated_item_info(
      ::message::ItemInfo* item_info);
  ::message::ItemInfo* unsafe_arena_release_item_info();

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 picked_object_id = 2;
  void clear_picked_object_id();
  uint64_t picked_object_id() const;
  void set_picked_object_id(uint64_t value);
  private:
  uint64_t _internal_picked_object_id() const;
  void _internal_set_picked_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.C_PickUp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::message::ItemInfo* item_info_;
  uint64_t object_id_;
  uint64_t picked_object_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class S_PickUp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.S_PickUp) */ {
 public:
  inline S_PickUp() : S_PickUp(nullptr) {}
  ~S_PickUp() override;
  explicit PROTOBUF_CONSTEXPR S_PickUp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PickUp(const S_PickUp& from);
  S_PickUp(S_PickUp&& from) noexcept
    : S_PickUp() {
    *this = ::std::move(from);
  }

  inline S_PickUp& operator=(const S_PickUp& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PickUp& operator=(S_PickUp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PickUp& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PickUp* internal_default_instance() {
    return reinterpret_cast<const S_PickUp*>(
               &_S_PickUp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(S_PickUp& a, S_PickUp& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PickUp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PickUp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PickUp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PickUp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PickUp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_PickUp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PickUp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.S_PickUp";
  }
  protected:
  explicit S_PickUp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kPickedObjectIdFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 picked_object_id = 2;
  void clear_picked_object_id();
  uint64_t picked_object_id() const;
  void set_picked_object_id(uint64_t value);
  private:
  uint64_t _internal_picked_object_id() const;
  void _internal_set_picked_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.S_PickUp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t object_id_;
  uint64_t picked_object_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_Login

// -------------------------------------------------------------------

// S_Login

// uint32 success = 1;
inline void S_Login::clear_success() {
  success_ = 0u;
}
inline uint32_t S_Login::_internal_success() const {
  return success_;
}
inline uint32_t S_Login::success() const {
  // @@protoc_insertion_point(field_get:message.S_Login.success)
  return _internal_success();
}
inline void S_Login::_internal_set_success(uint32_t value) {
  
  success_ = value;
}
inline void S_Login::set_success(uint32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:message.S_Login.success)
}

// repeated .message.ObjectInfo players = 2;
inline int S_Login::_internal_players_size() const {
  return players_.size();
}
inline int S_Login::players_size() const {
  return _internal_players_size();
}
inline ::message::ObjectInfo* S_Login::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:message.S_Login.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::ObjectInfo >*
S_Login::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:message.S_Login.players)
  return &players_;
}
inline const ::message::ObjectInfo& S_Login::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::message::ObjectInfo& S_Login::players(int index) const {
  // @@protoc_insertion_point(field_get:message.S_Login.players)
  return _internal_players(index);
}
inline ::message::ObjectInfo* S_Login::_internal_add_players() {
  return players_.Add();
}
inline ::message::ObjectInfo* S_Login::add_players() {
  ::message::ObjectInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:message.S_Login.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::ObjectInfo >&
S_Login::players() const {
  // @@protoc_insertion_point(field_list:message.S_Login.players)
  return players_;
}

// -------------------------------------------------------------------

// C_EnterRoom

// uint64 playerIndex = 1;
inline void C_EnterRoom::clear_playerindex() {
  playerindex_ = uint64_t{0u};
}
inline uint64_t C_EnterRoom::_internal_playerindex() const {
  return playerindex_;
}
inline uint64_t C_EnterRoom::playerindex() const {
  // @@protoc_insertion_point(field_get:message.C_EnterRoom.playerIndex)
  return _internal_playerindex();
}
inline void C_EnterRoom::_internal_set_playerindex(uint64_t value) {
  
  playerindex_ = value;
}
inline void C_EnterRoom::set_playerindex(uint64_t value) {
  _internal_set_playerindex(value);
  // @@protoc_insertion_point(field_set:message.C_EnterRoom.playerIndex)
}

// -------------------------------------------------------------------

// S_EnterRoom

// uint32 success = 1;
inline void S_EnterRoom::clear_success() {
  success_ = 0u;
}
inline uint32_t S_EnterRoom::_internal_success() const {
  return success_;
}
inline uint32_t S_EnterRoom::success() const {
  // @@protoc_insertion_point(field_get:message.S_EnterRoom.success)
  return _internal_success();
}
inline void S_EnterRoom::_internal_set_success(uint32_t value) {
  
  success_ = value;
}
inline void S_EnterRoom::set_success(uint32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:message.S_EnterRoom.success)
}

// .message.ObjectInfo player = 2;
inline bool S_EnterRoom::_internal_has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline bool S_EnterRoom::has_player() const {
  return _internal_has_player();
}
inline const ::message::ObjectInfo& S_EnterRoom::_internal_player() const {
  const ::message::ObjectInfo* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::ObjectInfo&>(
      ::message::_ObjectInfo_default_instance_);
}
inline const ::message::ObjectInfo& S_EnterRoom::player() const {
  // @@protoc_insertion_point(field_get:message.S_EnterRoom.player)
  return _internal_player();
}
inline void S_EnterRoom::unsafe_arena_set_allocated_player(
    ::message::ObjectInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.S_EnterRoom.player)
}
inline ::message::ObjectInfo* S_EnterRoom::release_player() {
  
  ::message::ObjectInfo* temp = player_;
  player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::message::ObjectInfo* S_EnterRoom::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:message.S_EnterRoom.player)
  
  ::message::ObjectInfo* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::message::ObjectInfo* S_EnterRoom::_internal_mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::message::ObjectInfo>(GetArenaForAllocation());
    player_ = p;
  }
  return player_;
}
inline ::message::ObjectInfo* S_EnterRoom::mutable_player() {
  ::message::ObjectInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:message.S_EnterRoom.player)
  return _msg;
}
inline void S_EnterRoom::set_allocated_player(::message::ObjectInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:message.S_EnterRoom.player)
}

// -------------------------------------------------------------------

// C_LeaveRoom

// -------------------------------------------------------------------

// S_LeaveRoom

// -------------------------------------------------------------------

// S_Spawn

// repeated .message.ObjectInfo players = 1;
inline int S_Spawn::_internal_players_size() const {
  return players_.size();
}
inline int S_Spawn::players_size() const {
  return _internal_players_size();
}
inline ::message::ObjectInfo* S_Spawn::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:message.S_Spawn.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::ObjectInfo >*
S_Spawn::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:message.S_Spawn.players)
  return &players_;
}
inline const ::message::ObjectInfo& S_Spawn::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::message::ObjectInfo& S_Spawn::players(int index) const {
  // @@protoc_insertion_point(field_get:message.S_Spawn.players)
  return _internal_players(index);
}
inline ::message::ObjectInfo* S_Spawn::_internal_add_players() {
  return players_.Add();
}
inline ::message::ObjectInfo* S_Spawn::add_players() {
  ::message::ObjectInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:message.S_Spawn.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::ObjectInfo >&
S_Spawn::players() const {
  // @@protoc_insertion_point(field_list:message.S_Spawn.players)
  return players_;
}

// -------------------------------------------------------------------

// S_Despawn

// repeated uint64 object_ids = 1;
inline int S_Despawn::_internal_object_ids_size() const {
  return object_ids_.size();
}
inline int S_Despawn::object_ids_size() const {
  return _internal_object_ids_size();
}
inline void S_Despawn::clear_object_ids() {
  object_ids_.Clear();
}
inline uint64_t S_Despawn::_internal_object_ids(int index) const {
  return object_ids_.Get(index);
}
inline uint64_t S_Despawn::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:message.S_Despawn.object_ids)
  return _internal_object_ids(index);
}
inline void S_Despawn::set_object_ids(int index, uint64_t value) {
  object_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:message.S_Despawn.object_ids)
}
inline void S_Despawn::_internal_add_object_ids(uint64_t value) {
  object_ids_.Add(value);
}
inline void S_Despawn::add_object_ids(uint64_t value) {
  _internal_add_object_ids(value);
  // @@protoc_insertion_point(field_add:message.S_Despawn.object_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_Despawn::_internal_object_ids() const {
  return object_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_Despawn::object_ids() const {
  // @@protoc_insertion_point(field_list:message.S_Despawn.object_ids)
  return _internal_object_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_Despawn::_internal_mutable_object_ids() {
  return &object_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_Despawn::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:message.S_Despawn.object_ids)
  return _internal_mutable_object_ids();
}

// -------------------------------------------------------------------

// C_Move

// .message.PosInfo PosInfo = 1;
inline bool C_Move::_internal_has_posinfo() const {
  return this != internal_default_instance() && posinfo_ != nullptr;
}
inline bool C_Move::has_posinfo() const {
  return _internal_has_posinfo();
}
inline const ::message::PosInfo& C_Move::_internal_posinfo() const {
  const ::message::PosInfo* p = posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::PosInfo&>(
      ::message::_PosInfo_default_instance_);
}
inline const ::message::PosInfo& C_Move::posinfo() const {
  // @@protoc_insertion_point(field_get:message.C_Move.PosInfo)
  return _internal_posinfo();
}
inline void C_Move::unsafe_arena_set_allocated_posinfo(
    ::message::PosInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.C_Move.PosInfo)
}
inline ::message::PosInfo* C_Move::release_posinfo() {
  
  ::message::PosInfo* temp = posinfo_;
  posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::message::PosInfo* C_Move::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:message.C_Move.PosInfo)
  
  ::message::PosInfo* temp = posinfo_;
  posinfo_ = nullptr;
  return temp;
}
inline ::message::PosInfo* C_Move::_internal_mutable_posinfo() {
  
  if (posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::message::PosInfo>(GetArenaForAllocation());
    posinfo_ = p;
  }
  return posinfo_;
}
inline ::message::PosInfo* C_Move::mutable_posinfo() {
  ::message::PosInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:message.C_Move.PosInfo)
  return _msg;
}
inline void C_Move::set_allocated_posinfo(::message::PosInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo));
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:message.C_Move.PosInfo)
}

// -------------------------------------------------------------------

// S_Move

// .message.PosInfo PosInfo = 1;
inline bool S_Move::_internal_has_posinfo() const {
  return this != internal_default_instance() && posinfo_ != nullptr;
}
inline bool S_Move::has_posinfo() const {
  return _internal_has_posinfo();
}
inline const ::message::PosInfo& S_Move::_internal_posinfo() const {
  const ::message::PosInfo* p = posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::PosInfo&>(
      ::message::_PosInfo_default_instance_);
}
inline const ::message::PosInfo& S_Move::posinfo() const {
  // @@protoc_insertion_point(field_get:message.S_Move.PosInfo)
  return _internal_posinfo();
}
inline void S_Move::unsafe_arena_set_allocated_posinfo(
    ::message::PosInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.S_Move.PosInfo)
}
inline ::message::PosInfo* S_Move::release_posinfo() {
  
  ::message::PosInfo* temp = posinfo_;
  posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::message::PosInfo* S_Move::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:message.S_Move.PosInfo)
  
  ::message::PosInfo* temp = posinfo_;
  posinfo_ = nullptr;
  return temp;
}
inline ::message::PosInfo* S_Move::_internal_mutable_posinfo() {
  
  if (posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::message::PosInfo>(GetArenaForAllocation());
    posinfo_ = p;
  }
  return posinfo_;
}
inline ::message::PosInfo* S_Move::mutable_posinfo() {
  ::message::PosInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:message.S_Move.PosInfo)
  return _msg;
}
inline void S_Move::set_allocated_posinfo(::message::PosInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo));
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:message.S_Move.PosInfo)
}

// -------------------------------------------------------------------

// C_Attack

// uint64 attack_object_id = 1;
inline void C_Attack::clear_attack_object_id() {
  attack_object_id_ = uint64_t{0u};
}
inline uint64_t C_Attack::_internal_attack_object_id() const {
  return attack_object_id_;
}
inline uint64_t C_Attack::attack_object_id() const {
  // @@protoc_insertion_point(field_get:message.C_Attack.attack_object_id)
  return _internal_attack_object_id();
}
inline void C_Attack::_internal_set_attack_object_id(uint64_t value) {
  
  attack_object_id_ = value;
}
inline void C_Attack::set_attack_object_id(uint64_t value) {
  _internal_set_attack_object_id(value);
  // @@protoc_insertion_point(field_set:message.C_Attack.attack_object_id)
}

// uint64 victim_object_id = 2;
inline void C_Attack::clear_victim_object_id() {
  victim_object_id_ = uint64_t{0u};
}
inline uint64_t C_Attack::_internal_victim_object_id() const {
  return victim_object_id_;
}
inline uint64_t C_Attack::victim_object_id() const {
  // @@protoc_insertion_point(field_get:message.C_Attack.victim_object_id)
  return _internal_victim_object_id();
}
inline void C_Attack::_internal_set_victim_object_id(uint64_t value) {
  
  victim_object_id_ = value;
}
inline void C_Attack::set_victim_object_id(uint64_t value) {
  _internal_set_victim_object_id(value);
  // @@protoc_insertion_point(field_set:message.C_Attack.victim_object_id)
}

// uint32 damage = 3;
inline void C_Attack::clear_damage() {
  damage_ = 0u;
}
inline uint32_t C_Attack::_internal_damage() const {
  return damage_;
}
inline uint32_t C_Attack::damage() const {
  // @@protoc_insertion_point(field_get:message.C_Attack.damage)
  return _internal_damage();
}
inline void C_Attack::_internal_set_damage(uint32_t value) {
  
  damage_ = value;
}
inline void C_Attack::set_damage(uint32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:message.C_Attack.damage)
}

// -------------------------------------------------------------------

// S_Attack

// uint64 object_id = 1;
inline void S_Attack::clear_object_id() {
  object_id_ = uint64_t{0u};
}
inline uint64_t S_Attack::_internal_object_id() const {
  return object_id_;
}
inline uint64_t S_Attack::object_id() const {
  // @@protoc_insertion_point(field_get:message.S_Attack.object_id)
  return _internal_object_id();
}
inline void S_Attack::_internal_set_object_id(uint64_t value) {
  
  object_id_ = value;
}
inline void S_Attack::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:message.S_Attack.object_id)
}

// repeated uint64 victims_object_ids = 2;
inline int S_Attack::_internal_victims_object_ids_size() const {
  return victims_object_ids_.size();
}
inline int S_Attack::victims_object_ids_size() const {
  return _internal_victims_object_ids_size();
}
inline void S_Attack::clear_victims_object_ids() {
  victims_object_ids_.Clear();
}
inline uint64_t S_Attack::_internal_victims_object_ids(int index) const {
  return victims_object_ids_.Get(index);
}
inline uint64_t S_Attack::victims_object_ids(int index) const {
  // @@protoc_insertion_point(field_get:message.S_Attack.victims_object_ids)
  return _internal_victims_object_ids(index);
}
inline void S_Attack::set_victims_object_ids(int index, uint64_t value) {
  victims_object_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:message.S_Attack.victims_object_ids)
}
inline void S_Attack::_internal_add_victims_object_ids(uint64_t value) {
  victims_object_ids_.Add(value);
}
inline void S_Attack::add_victims_object_ids(uint64_t value) {
  _internal_add_victims_object_ids(value);
  // @@protoc_insertion_point(field_add:message.S_Attack.victims_object_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_Attack::_internal_victims_object_ids() const {
  return victims_object_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_Attack::victims_object_ids() const {
  // @@protoc_insertion_point(field_list:message.S_Attack.victims_object_ids)
  return _internal_victims_object_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_Attack::_internal_mutable_victims_object_ids() {
  return &victims_object_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_Attack::mutable_victims_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:message.S_Attack.victims_object_ids)
  return _internal_mutable_victims_object_ids();
}

// uint32 damage = 3;
inline void S_Attack::clear_damage() {
  damage_ = 0u;
}
inline uint32_t S_Attack::_internal_damage() const {
  return damage_;
}
inline uint32_t S_Attack::damage() const {
  // @@protoc_insertion_point(field_get:message.S_Attack.damage)
  return _internal_damage();
}
inline void S_Attack::_internal_set_damage(uint32_t value) {
  
  damage_ = value;
}
inline void S_Attack::set_damage(uint32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:message.S_Attack.damage)
}

// -------------------------------------------------------------------

// C_PickUp

// uint64 object_id = 1;
inline void C_PickUp::clear_object_id() {
  object_id_ = uint64_t{0u};
}
inline uint64_t C_PickUp::_internal_object_id() const {
  return object_id_;
}
inline uint64_t C_PickUp::object_id() const {
  // @@protoc_insertion_point(field_get:message.C_PickUp.object_id)
  return _internal_object_id();
}
inline void C_PickUp::_internal_set_object_id(uint64_t value) {
  
  object_id_ = value;
}
inline void C_PickUp::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:message.C_PickUp.object_id)
}

// uint64 picked_object_id = 2;
inline void C_PickUp::clear_picked_object_id() {
  picked_object_id_ = uint64_t{0u};
}
inline uint64_t C_PickUp::_internal_picked_object_id() const {
  return picked_object_id_;
}
inline uint64_t C_PickUp::picked_object_id() const {
  // @@protoc_insertion_point(field_get:message.C_PickUp.picked_object_id)
  return _internal_picked_object_id();
}
inline void C_PickUp::_internal_set_picked_object_id(uint64_t value) {
  
  picked_object_id_ = value;
}
inline void C_PickUp::set_picked_object_id(uint64_t value) {
  _internal_set_picked_object_id(value);
  // @@protoc_insertion_point(field_set:message.C_PickUp.picked_object_id)
}

// .message.ItemInfo item_info = 3;
inline bool C_PickUp::_internal_has_item_info() const {
  return this != internal_default_instance() && item_info_ != nullptr;
}
inline bool C_PickUp::has_item_info() const {
  return _internal_has_item_info();
}
inline const ::message::ItemInfo& C_PickUp::_internal_item_info() const {
  const ::message::ItemInfo* p = item_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::ItemInfo&>(
      ::message::_ItemInfo_default_instance_);
}
inline const ::message::ItemInfo& C_PickUp::item_info() const {
  // @@protoc_insertion_point(field_get:message.C_PickUp.item_info)
  return _internal_item_info();
}
inline void C_PickUp::unsafe_arena_set_allocated_item_info(
    ::message::ItemInfo* item_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_info_);
  }
  item_info_ = item_info;
  if (item_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.C_PickUp.item_info)
}
inline ::message::ItemInfo* C_PickUp::release_item_info() {
  
  ::message::ItemInfo* temp = item_info_;
  item_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::message::ItemInfo* C_PickUp::unsafe_arena_release_item_info() {
  // @@protoc_insertion_point(field_release:message.C_PickUp.item_info)
  
  ::message::ItemInfo* temp = item_info_;
  item_info_ = nullptr;
  return temp;
}
inline ::message::ItemInfo* C_PickUp::_internal_mutable_item_info() {
  
  if (item_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::message::ItemInfo>(GetArenaForAllocation());
    item_info_ = p;
  }
  return item_info_;
}
inline ::message::ItemInfo* C_PickUp::mutable_item_info() {
  ::message::ItemInfo* _msg = _internal_mutable_item_info();
  // @@protoc_insertion_point(field_mutable:message.C_PickUp.item_info)
  return _msg;
}
inline void C_PickUp::set_allocated_item_info(::message::ItemInfo* item_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_info_);
  }
  if (item_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_info));
    if (message_arena != submessage_arena) {
      item_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item_info, submessage_arena);
    }
    
  } else {
    
  }
  item_info_ = item_info;
  // @@protoc_insertion_point(field_set_allocated:message.C_PickUp.item_info)
}

// -------------------------------------------------------------------

// S_PickUp

// uint64 object_id = 1;
inline void S_PickUp::clear_object_id() {
  object_id_ = uint64_t{0u};
}
inline uint64_t S_PickUp::_internal_object_id() const {
  return object_id_;
}
inline uint64_t S_PickUp::object_id() const {
  // @@protoc_insertion_point(field_get:message.S_PickUp.object_id)
  return _internal_object_id();
}
inline void S_PickUp::_internal_set_object_id(uint64_t value) {
  
  object_id_ = value;
}
inline void S_PickUp::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:message.S_PickUp.object_id)
}

// uint64 picked_object_id = 2;
inline void S_PickUp::clear_picked_object_id() {
  picked_object_id_ = uint64_t{0u};
}
inline uint64_t S_PickUp::_internal_picked_object_id() const {
  return picked_object_id_;
}
inline uint64_t S_PickUp::picked_object_id() const {
  // @@protoc_insertion_point(field_get:message.S_PickUp.picked_object_id)
  return _internal_picked_object_id();
}
inline void S_PickUp::_internal_set_picked_object_id(uint64_t value) {
  
  picked_object_id_ = value;
}
inline void S_PickUp::set_picked_object_id(uint64_t value) {
  _internal_set_picked_object_id(value);
  // @@protoc_insertion_point(field_set:message.S_PickUp.picked_object_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::message::HEADER> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::HEADER>() {
  return ::message::HEADER_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Message_2eproto
